# 3.1. Módulo Padrões de Projeto GoFs Criacionais

<!-- Foco_01: Padrões de Projeto GoFs Criacionais

Entrega Mínima: 1 Padrão GoF Criacional, com nível de modelagem e nível de implementação evidenciados (ou seja, código rodando e hospedado no repositório do projeto).

Apresentação (em sala) explicando o GoF Criacional, com: (i) rastro claro aos membros participantes (MOSTRAR QUADRO DE PARTICIPAÇÕES & COMMITS); (ii) justificativas & senso crítico sobre o padrão GOF criacional, e (iii) comentários gerais sobre o trabalho em equipe. Tempo da Apresentação: +/- 5min. Recomendação: Apresentar diretamente via Wiki ou GitPages do Projeto. Baixar os conteúdos com antecedência, evitando problemas de internet no momento de exposição nas Dinâmicas de Avaliação.

A Wiki ou GitPages do Projeto deve conter um tópico dedicado ao Módulo Padrões de Projeto GoFs Criacionais, com 1 padrão GoF Criacional (modelagem & implementação), histórico de versões, referências, e demais detalhamentos gerados pela equipe nesse escopo.

Demais orientações disponíveis nas Diretrizes (vide Moodle). -->

## Factory Method

O padrão de projeto Factory Method foi utilizado para encapsular a lógica de criação de um objeto User com base nos dados recebidos no CreateUserDto. Esse padrão é útil porque centraliza a criação de objetos, promovendo reuso, padronização e organização do código.

A seguir tem a imagens da implementação:

<div style="text-align: center;">
    <img src="./image/classe-user-factory.png" alt="Classe UserFactory">
</div>
<figcaption align='center'>
    <h6><b>Figura 1: Classe UserFactory. Autor(es): Gabriel Marcolino e Shaíne Oliveira</h6></b>
</figcaption>

## Builder

O padrão **Builder** permite a construção de objetos complexos passo a passo. Ele foi utilizado no método `updateUser` para construir o objeto `UpdateUserDto` e no `deleteUser` para construir a resposta da requisição.

## Rastreabilidade e Elos com Outros Artefatos

- **Camada de Serviço**: Usa o objeto configurado pelo Builder para a lógica de negócio.
- **Camada de Repositório**: Recebe o objeto `UpdateUserDto` construído pelo Builder para enviar ao banco.

## Implementação

### Classe Builder:

```typescript
export class UserResponseDtoBuilder {
  private data: UserResponseDto;
  
  constructor() {
    this.data = new UserResponseDto();
  }

  setName(name: string): UserResponseDtoBuilder {
    this.data.name = name;
    return this;
  }

  setCpfCnpj(cpf_cnpj: string): UserResponseDtoBuilder {
    this.data.cpf_cnpj = cpf_cnpj;
    return this;
  }

  setEmail(email: string): UserResponseDtoBuilder {
    this.data.email = email;
    return this;
  }

  setSite(site: string): UserResponseDtoBuilder {
    this.data.site = site;
    return this;
  }

  build(): UserResponseDto {
    return this.data;
  }
}
```

### Uso no Método `updateUser`:

```typescript
const builder = new UpdateUserBuilder();
const userResponse = builder
  .setName(data.name)
  .setCpfCnpj(data.cpf_cnpj)
  .setEmail(data.email)
  .setSite(data.site)
  .build();
```

### Uso no Método `deleteUser`:
```typescript
    const builder = new UserResponseDtoBuilder();
    const userResponse = builder
      .setName(deletedUser.name)
      .setCpfCnpj(deletedUser.cpf_cnpj)
      .setEmail(deletedUser.email)
      .setSite(deletedUser.site)
      .build();
```

## Senso Crítico

### Por que Builder?

- Evita que a lógica de configuração de objetos fique espalhada no código.

### Pontos Positivos:

- Facilita a adição de novos campos sem alterar o método principal.

### Limitações:

- Requer mais esforço inicial para configurar o Builder.

# Singleton

O padrão **Singleton** foi utilizado para garantir que apenas uma instância da classe `ApiService` seja criada e compartilhada entre os componentes que a utilizam. Isso é util para padronizar o acesso a recursos compartilhados e evitar problemas de concorrência.

## Implementação 1

## Rastreabilidade e Elos com Outros Artefatos

- **Camada de Serviço**: Usa a instância única de `ApiService` para fazer requisições HTTP.
- **Camada de Repositório**: Recebe os dados obtidos pela `ApiService` para persistir no banco.


### Classe Singleton:

```typescript
export class ApiService {
  constructor(private http: HttpClient) {}

  httpOptions(contentType = 'application/json', hasContentType = true): any {
    if (hasContentType) {
      return {
        headers: new HttpHeaders({
          'Content-Type': contentType,
        }),
      };
    }
    return undefined;
  }

  get<T = any>(controller: string): Observable<T> {
    return this.http
      .get<T>(`${APP_API}/${controller}`, {
        ...this.httpOptions,
      })
      .pipe(map((res) => res));
  }

  ...
}
```

### Uso no Método `getAllImoveis`:

```typescript
    constructor(private apiService: ApiService) {}

    getAllImoveis() {
      return this.apiService.get(`/imovel`);
    }

    ...
```

---
## Implementação 2
O padrão **Singleton** foi utilizado na classe `TokenManager` para garantir que apenas uma instância da classe seja criada e compartilhada durante todo o ciclo de vida da aplicação. Isso é útil para padronizar o acesso ao gerenciamento de tokens e evitar a criação de múltiplas instâncias que possam consumir recursos desnecessários.
## Rastreabilidade e Elos com Outros Artefatos
- **Camada de Serviço**: A instância única de `TokenManager` é injetada nos serviços para gerar e verificar tokens de autenticação.
- **Camada de Autenticação**: Utiliza o `TokenManager` para validar e gerar tokens JWT, centralizando a lógica de autenticação.
### Classe Singleton:
```typescript
import { Injectable } from '@nestjs/common';
import * as jwt from 'jsonwebtoken';
@Injectable()
export class TokenManager {
  private readonly secret = 'asdasdasd123123'; 
  generateToken(payload: any): string {
    return jwt.sign(payload, this.secret, { expiresIn: '1h' });
  }
  verifyToken(token: string): any {
    try {
      return jwt.verify(token, this.secret);
    } catch (error) {
      throw new Error('Invalid token');
    }
  }
}
```
### Uso no Método `login`:
```typescript
import { Injectable } from "@nestjs/common";
import { PasswordAuthStrategy } from "./strategies/password.auth.strategy";
import { TokenManager } from "./token.manager";
import { UnauthorizedException } from "@nestjs/common"; 
@Injectable()
export class PasswordAuth {
  constructor(
    private readonly strategy: PasswordAuthStrategy,
    private readonly tokenManager: TokenManager,
  ) {}
  async login(email: string, password: string): Promise<any> {
    const user = await this.strategy.authenticate(email, password);
    
    if (!user) {
      throw new UnauthorizedException('Invalid credentials'); 
    }
    
    return this.tokenManager.generateToken({ id: user.id, email: user.email });
  }
}
```
---

## Senso Crítico

### Por que Singleton?

- Garante que apenas uma instância de `ApiService` seja criada e compartilhada.

### Pontos positivos:

- Padroniza o acesso a recursos compartilhados.
- Evita problemas de concorrência.

### Limitações:

- Requer mais esforço inicial para configurar o Singleton.

## Referências

1. Refactoring Guru. Disponível em: <https://refactoring.guru/pt-br>. Ultimo acesso em: 3 de janeiro de 2025.

## Histórico de Versão

| Versão |    Data    |                    Descrição                     |                                                 Autor(es)                                                  |
| :----: | :--------: | :----------------------------------------------: | :--------------------------------------------------------------------------------------------------------: |
| `1.0`  | 02/01/2025 |      Adicionando padrão de projeto Factory       | [Gabriel Marcolino](https://github.com/GabrielMR360), [Shaíne Oliveira](https://github.com/ShaineOliveira) |
| `2.0`  | 04/01/2025 |  Implementação e documentação do Padrão Builder  |    [Arthur Gabriel](https://github.com/ArthurGabrieel), [Miguel Moreira](https://github.com/EhOMiguel)     |
| `3.0`  | 04/01/2025 |       Adaptação do desing pattern builder        |    [Arthur Gabriel](https://github.com/ArthurGabrieel), [Miguel Moreira](https://github.com/EhOMiguel)     |
| `4.0`  | 04/01/2025 | Implementação e documentação do Padrão Singleton |               [Lucas Macedo](https://github.com/Luckx98), [Ester Lino](esteerlino@gmail.com)               |
| `4.1`  | 05/01/2025 | Adição do método deleteUser ao design pattern builder | [Pedro Sena](https://github.com/pedroyen21) |
| `4.2`  | 06/01/2025 | Adição do método verifyToken ao design pattern Singleton | [Pedro Izarias](https://github.com/Izarias), [Gabriel Bertolazi](https://github.com/Bertolazi)  |
