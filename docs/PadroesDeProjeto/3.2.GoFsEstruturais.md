# 3.2. Módulo Padrões de Projeto GoFs Estruturais

<!-- Foco_2: Padrões de Projeto GoFs Estruturais.

Entrega Mínima: 1 Padrão GoF Estrutural, com nível de modelagem e nível de implementação evidenciados (ou seja, código rodando e hospedado no repositório do projeto).

Apresentação (em sala) explicando o GoF Estrutural, com: (i) rastro claro aos membros participantes (MOSTRAR QUADRO DE PARTICIPAÇÕES & COMMITS); (ii) justificativas & senso crítico sobre o padrão GOF estrutural; e (iii) comentários gerais sobre o trabalho em equipe. Tempo da Apresentação: +/- 5min. Recomendação: Apresentar diretamente via Wiki ou GitPages do Projeto. Baixar os conteúdos com antecedência, evitando problemas de internet no momento de exposição nas Dinâmicas de Avaliação.

A Wiki ou GitPages do Projeto deve conter um tópico dedicado ao Módulo Padrões de Projeto GoFs Estruturais, com 1 padrão GoF Estrutural (modelagem & implementação), histórico de versões, referências, e demais detalhamentos gerados pela equipe nesse escopo.

Demais orientações disponíveis nas Diretrizes (vide Moodle). -->

## Adapter

O padrão **Adapter** foi aplicado para normalizar os números de telefone antes de serem enviados ao banco de dados. Ele converte a estrutura dos números para o formato esperado, encapsulando a lógica de normalização em uma única classe reutilizável.

## Rastreabilidade e Elos com Outros Artefatos
- **Camada de Repositório**: Usa os dados normalizados pelo Adapter.
- **Banco de Dados**: Recebe os números no formato esperado.

## Implementação
### Classe Adapter:

```typescript
export class TelephoneAdapter {
    static adapt(telephones: { number: string }[]): { number: string }[] {
      return telephones.map((tel) => ({
        number: tel.number.replace(/[^0-9]/g, ''),
      }));
    }
  }
```


### Uso no Método updateUser:
```typescript
const adaptedTelephones = userData.telephone
    ? TelephoneAdapter.adapt(userData.telephone)
    : undefined;
```


## Senso Crítico
### Por que Adapter?
- Encapsula a lógica de normalização, promovendo reutilização e modularidade.

### Pontos Positivos:
- Facilita a adaptação para novos requisitos de formatação.
- Torna o código principal mais limpo e focado.

### Limitações:
- Introduz uma camada extra de abstração, o que pode ser desnecessário em casos simples.


## Decorator

O padrão **Decorator** foi aplicado para adicionar praticidade ao log de erros de métodos.

## Rastreabilidade e Elos com Outros Artefatos
- **User Repository**: Usa o Decorator.
- **Decorator**: Implementa log dos parâmetros usados pelo método e qual erro ocorreu.

## Implementação
### Classe LogOnErrorUtil:

```typescript
export class LogOnErrorUtil {
  static create(): MethodDecorator {
    return function (target, propertyKey, descriptor: any) {
      const originalMethod = descriptor.value;

      descriptor.value = async function (...args: any[]) {
        try {
          return await originalMethod.apply(this, args);
        } catch (error) {
          console.error(
            `Erro ao executar ${String(propertyKey)} com os parâmetros:`,
            args,
          );
          console.error('Detalhes do erro:', error);
          throw error;
        }
      };

      return descriptor;
    };
  }
}

```


### Uso no Método deleteUser da classe UserRepository:
```typescript
  @LogOnErrorUtil.create()
  async deleteUser(cpf_cnpj: string): Promise<User> {
    await this.prisma.telephone.deleteMany({
      where: { userId: cpf_cnpj },
    });

    const deletedUser = await this.prisma.user.delete({
      where: { cpf_cnpj: cpf_cnpj },
    });

    return deletedUser;
  }
```


## Senso Crítico
### Por que Decorator?
- Encapsula a lógica de logs.

### Pontos Positivos:
- Centraliza a lógica de logs de métodos da aplicaçaõ.
- Torna o código principal mais limpo.
- Possibilita a economia de código para logs de erro.

### Limitações:
- Caso haja erro na implementação do código, todos os locais onde o decorator for aplicado, ele causará defeito.

---
## Facade
O padrão **Facade** foi aplicado para simplificar o processo de autenticação no sistema, fornecendo uma interface única e clara para a verificação de credenciais e geração de tokens.
## Rastreabilidade e Elos com Outros Artefatos
- **AuthService**: Usa o `PasswordAuth` para realizar o processo de login, sem expor os detalhes das estratégias de autenticação e geração de tokens.
- **PasswordAuth**: Encapsula a lógica de autenticação e de geração de tokens.
## Implementação
### Classe Facade:
```typescript
@Injectable()
export class PasswordAuth {
  constructor(
    private readonly strategy: PasswordAuthStrategy,
    private readonly tokenManager: TokenManager,
  ) {}
  async login(email: string, password: string): Promise<any> {
    const user = await this.strategy.authenticate(email, password);
    
    if (!user) {
      throw new UnauthorizedException('Invalid credentials'); 
    }
    
    return this.tokenManager.generateToken({ id: user.id, email: user.email });
  }
}
```
### Uso no Método login do AuthService:
```typescript
@Injectable()
export class AuthService {
  constructor(
    private passwordAuth: PasswordAuth,
    private tokenManager: JwtService, 
  ) {}
  async login(loginDto: LoginDto) {
    const user = await this.passwordAuth.login(loginDto.email, loginDto.password);
    if (!user) {
      throw new Error('Usuário ou senha inválidos');
    }
    const token = this.tokenManager.sign({
      id: user.id,
      email: user.email,
    });
    return { token };
  }
}
```
## Senso Crítico
### Por que Facade?
- Simplifica a interface de autenticação, unificando a lógica em um único ponto de acesso.
- Reduz o acoplamento entre os componentes internos (estratégia de autenticação e gerenciador de tokens) e a camada que consome a funcionalidade.
### Pontos Positivos:
- Fornece uma interface clara e consistente para o cliente.
- Encapsula a complexidade de processos internos como autenticação e geração de tokens.
- Facilita a substituição ou evolução dos componentes internos sem impactar os consumidores.
### Limitações:
- Introduz mais uma camada na arquitetura, o que pode ser desnecessário em sistemas muito simples.
- A implementação exige atenção para evitar que a fachada cresça demais, acumulando responsabilidades de outras camadas.

## Referências

1. Refactoring Guru. Disponível em: <https://refactoring.guru/pt-br>. Ultimo acesso em: 3 de janeiro de 2025.

## Histórico de Versão

| Versão |    Data    |           Descrição           |     Autor(es)         |
| :----: | :--------: | :---------------------------: | :--------------------:|
| `1.0`  | 04/01/2025 | Implementação e documentação do Padrão Adapter | [Arthur Gabriel](https://github.com/ArthurGabrieel), [Miguel Moreira](https://github.com/EhOMiguel) |
| `2.0`  | 05/01/2025 | Implementação e documentação do Padrão Decorator | [Pedro Sena](https://github.com/pedroyen21) |
| `3.0`  | 06/01/2025 | Implementação e documentação do Padrão Facade | [Pedro Izarias](https://github.com/Izarias), [Gabriel Bertolazi](https://github.com/Bertolazi)|
